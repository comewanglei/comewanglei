# -*- coding: utf-8 -*-
"""
Created on Thu Jul  5 15:28:39 2018

@author: wanglei
"""

import tornado.ioloop
import tornado.web
import psycopg2
import sys
import json
import decimal
import numpy as np
from scipy.spatial import ConvexHull
sys.setrecursionlimit(1000)  # set the maximum depth as 1000

conn = psycopg2.connect(database="jingkai", user="postgres", password="postgres", host="127.0.0.1", port="5432")
print ("成功连接数据库")
cur = conn.cursor()
###################################函数集合#############################################
# 纵剖面
class DecimalEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, decimal.Decimal):
            return float(obj)
        return super(DecimalEncoder, self).default(obj)
def vertical_profile_fun(node1,node2,pipe_table):
    sql_str=('''SELECT id2 AS gid,设备编,round(管长::numeric,2) as pipe_length,
       round(起点埋::numeric,2) as start_depth ,round(终点埋::numeric,2) as end_depth, 材质,ST_AsText(tn.geom)
        FROM pgr_dijkstra('  
        SELECT gid AS id,                      
        source::integer,                         
        target::integer,                        
        length::double precision AS cost  
        FROM %s',  
        %d,%d, false, false) AS di
        JOIN %s tn
        ON di.id2 = tn.gid''')%(pipe_table,int(node1),int(node2),pipe_table)
    cur.execute(sql_str)
    columns = ("gid",u"设备编号",u"管长",u"起点埋深",u"终点埋深","材质","geom")
    results = []
    for row in cur.fetchall():
        results.append(dict(zip(columns, row)))
    return json.dumps(results, cls=DecimalEncoder)
# 横剖面
def horizontal_profile_fun(linestr,pipe_table):
    sql_str=('''select 材质,设备编,round(管长::numeric,2) as pipe_length,
       round(起点埋::numeric,2) as start_depth ,round(终点埋::numeric,2) as end_depth
       from %s c
       where ST_Intersects(ST_GeomFromText('%s'),c.geom)''')%(pipe_table,linestr)
    cur.execute(sql_str)
    columns = (u"材质",u"设备编号",u"管长",u"起点埋深",u"终点埋深")
    results = []
    for row in cur.fetchall():
        results.append(dict(zip(columns, row)))
    return json.dumps(results, cls=DecimalEncoder)
#画多边形选择范围内的数据类型
def polygon_inter(linestring,table_name):
    sql_str = ("SELECT c.gid,ST_AsText(c.geom) FROM %s c where ST_Intersects(ST_MakePolygon(ST_GeomFromText('%s')),c.geom) IS TRUE")%(table_name,linestring) 
    cur.execute(sql_str)
    return cur.fetchall()

#线的buffer 范围内的数据
def linebuffer_inter(linestring,table_name,dis):
    sql_str=("SELECT c.gid,ST_AsText(c.geom) from %s c where ST_Intersects(ST_Buffer(ST_GeomFromText('%s'),%d,'endcap=round join=round'),c.geom) IS TRUE")%(table_name,linestring,int(dis))
    cur.execute(sql_str)
    return cur.fetchall()

#点的buffer 范围内的数据
def pointbuffer_inter(x,y,table_name,dis):
    sql_str=("SELECT c.gid,ST_AsText(c.geom) from %s c where ST_Intersects(ST_Buffer(ST_MakePoint(%f, %f),%d,'quad_segs=8'),c.geom) IS TRUE")%(table_name,float(x),float(y),int(dis))
    cur.execute(sql_str)
    return cur.fetchall()

#通过gid获取节点
def linegid_getvertice(pipe_table,vertices_table,gid_num):
    sql_str=("select n.id from %s p,%s n where ST_Intersects(p.geom,n.the_geom) and p.gid = %d limit 1")%(pipe_table,vertices_table,int(gid_num))
    cur.execute(sql_str)
    return cur.fetchall()

#通过获取的id节点进行连通性分析
def lt_analysis_fun(node1,node2,table_name):
    sql_str=('''SELECT tn.gid,ST_AsText(tn.geom) FROM pgr_dijkstra('  
            SELECT gid AS id,                      
            source::integer,                         
            target::integer,                        
            length::double precision AS cost  
            FROM %s',  
            %d,%d, false, false) AS di
            JOIN %s tn
            ON di.id2 = tn.gid''')%(table_name,int(node1),int(node2),table_name)
    cur.execute(sql_str)
    return cur.fetchall()

#路径规划分析
#step01 获取连通性路径集合
def get_roadLines(tb_name,l_n1,l_n2):
    '''
    l_n1 为开始点所在线的source
    l_n2 为结束点所在线的target
    '''
    sql_str=('''SELECT road_table.gid,ST_ASText(road_table.geom) FROM 
             (SELECT seq, id1 AS node, id2 AS edge, cost  FROM pgr_dijkstra(' 
             SELECT gid AS id,                   
             source::integer,                         
             target::integer,                       
             length::double precision AS cost 
             FROM %s', 
             %d, %d, false, false))AS di
             JOIN %s road_table
             ON di.edge = road_table.gid''')%(tb_name,int(l_n1),int(l_n2),tb_name)
    cur.execute(sql_str)
    return cur.fetchall()

def lines_2_line(arr):
    line_begin = "MULTILINESTRING("
    line_end = ")"
    for i in range(len(arr)):
        line_dui = arr[i][1][16:][:-1]
        if i == len(arr)-1:
            line_begin = line_begin+line_dui
        else:
            line_begin = line_begin+line_dui+','

    return line_begin+line_end

#step02 多条线段拼成一条线段
def line_segmentize(arr,dis):
    '''
    arr 为get_roadLines中返回的结果
    '''
    line_re = lines_2_line(arr)
    #注意单位，4326与3857的问题
    sql_str = ('''SELECT
               ST_AsText(ST_Pointn(geom, generate_series(1, ST_NumPoints(geom)-1))) as start_point, 
               ST_AsText(ST_Pointn(geom, generate_series(2, ST_NumPoints(geom)))) as end_point
              FROM(SELECT ST_Segmentize(st_geomfromtext(oneline.st_astext),%d)AS geom
              FROM(SELECT ST_AsText(ST_LineMerge(ST_GeomFromText('%s')))) AS oneline)AS line''')%(int(dis),line_re)
    cur.execute(sql_str)
    return cur.fetchall()

#step03 对生成一条线求buffer
def line_2_buffer(arr,dis):
    '''
    arr 为get_roadLines中返回的结果
    '''
    line_re = lines_2_line(arr)
    #注意buffer的单位
    sql_str = ('''
               SELECT 
               ST_AsText(ST_BUffer(ST_GeomFromText(line.st_astext),%d,'endcap=round join=round'))
               FROM(SELECT ST_AsText(ST_LineMerge(ST_GeomFromText('%s'))))AS line
               ''')%(int(dis),line_re)
    cur.execute(sql_str)
    return cur.fetchall()

#查找点最近的对应的数据
def get_nearest(x,y,table_name,threshold):
    sql_str = ('''
                select row_to_json(t)
                from(
                        select t.*,ST_ASText(t.geom) as geom_wkt,st_distance(ST_MakePoint(%f, %f),t.geom) as len
                        from %s t
                        where st_distance(ST_MakePoint(%f, %f),t.geom) < %f
                        order by len ASC
                        limit 1
                ) as t
                ''')%(float(x),float(y),table_name,float(x),float(y),float(threshold))
    cur.execute(sql_str)
    return cur.fetchall()
#根据gid查找数据
def gid_getdata(gid_num,table_name):
    sql_str = ('''
               select row_to_json(t)
                from(
                 select c.*,ST_ASText(c.geom) as geom_wkt
                 from %s c
                 where c.gid = %d
                ) as t
               ''')%(table_name,int(gid_num))
    cur.execute(sql_str)
    return cur.fetchall()   

#####爆管分析计算函数
def get_inter_line(table_name,gid_num):
    sql_str = ("SELECT b.gid,ST_AsText(b.geom) from %s a, %s b where ST_Touches(a.geom, b.geom) and a.gid=%d")%(table_name,table_name,gid_num)
    cur.execute(sql_str)
    return cur.fetchall()

#判断是否存在点在线上
def get_inter_node(line_table_name,node_table_name,gid_num):
    #查询与线相交的点儿（即在线上的阀门点儿）
     sql_str = ("SELECT b.gid,ST_AsText(b.geom) from %s a, %s b where ST_Intersects(a.geom, b.geom) and a.gid=%d")%(line_table_name,node_table_name,gid_num)
     cur.execute(sql_str)
     return cur.fetchall()

def point_in_line(point,line):
    #判断点是否在线上，在线上返回true
    sql_str = ("SELECT ST_Intersects(ST_GeomFromText(ST_AsText('%s')),ST_GeomFromText(ST_AsText('%s')))")%(point,line)
    cur.execute(sql_str)
    return cur.fetchall()
#通过gid 获取geom
def get_geom(table_name,gid):
    sql_str = ("SELECT ST_AsText(a.geom) from %s a where a.gid = %d")%(table_name,gid)
    cur.execute(sql_str)
    return cur.fetchall()
#获取最外部的包裹面
def get_ConvexHull(line_arr):
    points = []
    line_arr = list(set(line_arr))
    for data in line_arr:
        data_split = data[1].split('((')[1].split('))')[0].split(',')
        for data_sp in data_split:
            re = data_sp.split(' ')
            points.append([re[0],re[1]])
    points_arr = np.array(points)
    try:
        hull = ConvexHull(points_arr)
        result =[]
        for ver in hull.vertices:
            result.append(points[ver])
        return result
    except:
        return [[0,0]]
#递归获取最终的line and node
line_arr = [] #管线集合
node_arr = [] #node点集合
line_gid_mid = [] #由于st_intersects 会判断出线的多个方向的连接情况
def get_result(line_table_name,node_table_name,ori_gid_num):
    #line_table_name 管网所在表
    #node_table_name 阀门所在表
    #ori_gid_num 爆管所在管线的gid值
    
    #情景一 当目标线的两端已经是两个端点时
    node_panduan = get_inter_node(line_table_name,node_table_name,ori_gid_num)
    if len(node_panduan) == 2:
#        line_arr.append(ori_gid_num)
        temp2 =(ori_gid_num,get_geom(line_table_name,ori_gid_num)[0][0])
        line_arr.append(temp2)
        node_arr.append(node_panduan[0])
        node_arr.append(node_panduan[1])
    else:
        #情景二 当目标线段的两端有一个端点时
        line_array_temp = []
        if len(node_panduan) == 1:
#            line_arr.append(ori_gid_num)
            temp1 =(ori_gid_num,get_geom(line_table_name,ori_gid_num)[0][0])
            line_arr.append(temp1)
            node_arr.append(node_panduan[0])
            line_arra = get_inter_line(line_table_name,ori_gid_num)#获取与ori_gid相交的线
            for line in line_arra:                                 #遍历 node与线进行point in line判断
                if point_in_line(node_panduan[0][-1],line[-1])[0][0] == False:  #当node与相邻的线不相交时，放入line_array_temp
                    line_array_temp.append(line)
        #情景三 当目标线段两端没有端点时
        else:    
            line_array_temp = get_inter_line(line_table_name,ori_gid_num)
            
        #进行循环获取筛选
        line_array = line_array_temp
        for line in line_array:
            gid_num = line[0]
            if gid_num not in line_gid_mid:
                node_panduan = get_inter_node(line_table_name,node_table_name,gid_num)
                if len(node_panduan)==0:
                    line_arr.append(line)
                    line_gid_mid.append(line[0])
                    get_result(line_table_name,node_table_name,gid_num)
                elif node_panduan[0] not in node_arr:
                    line_arr.append(line)
                    line_gid_mid.append(line[0])            
                    node_arr.append(node_panduan[0])
#二次爆管分析
line_arr_tw = [] #管线集合
node_arr_tw = [] #node点集合
line_gid_mid_tw = [] #由于st_intersects 会判断出线的多个方向的连接情况
def get_result_twice(line_table_name,node_table_name,ori_gid_num,famen_gid_num):
    #line_table_name 管网所在表
    #node_table_name 阀门所在表
    #ori_gid_num 爆管所在管线的gid值
    #famen_gid_num 失效的阀门的gid值 先考虑单个阀门时
    
    #情景一 当目标线的两端已经是两个端点时
    node_panduan = get_inter_node(line_table_name,node_table_name,ori_gid_num)
    if len(node_panduan) == 2:
        #对两个点循环进行操作
#        line_arr_tw.append(ori_gid_num)
        temp2_tw =(ori_gid_num,get_geom(line_table_name,ori_gid_num)[0][0])
        line_arr_tw.append(temp2_tw)
        for node in node_panduan:
            if node[0] != famen_gid_num:
                node_arr_tw.append(node)
            else:
                line_array_temp = get_inter_line(line_table_name,ori_gid_num)
                for linee in line_array_temp:
                    if point_in_line(node[-1],linee[-1])[0][0] == True:
                        get_result_twice(line_table_name,node_table_name,linee[0],famen_gid_num)        
    else:
        #情景二 当目标线段的两端有一个端点时
        line_array_temp = []
        if len(node_panduan) == 1:
            if node_panduan[0][0] == famen_gid_num:
                line_array_temp = get_inter_line(line_table_name,ori_gid_num)
                line_array = line_array_temp
                for line in line_array:
                    gid_num = line[0]
                    if gid_num not in line_gid_mid_tw:
                        node_panduan = get_inter_node(line_table_name,node_table_name,gid_num)
                        #判断失效阀门点儿是不是在node_panduan里边
                        #此时的线上肯定不会又两个阀门儿点儿
                        if len(node_panduan)==0:
                            line_arr_tw.append(line)
                            line_gid_mid_tw.append(line[0])
                            get_result_twice(line_table_name,node_table_name,gid_num,famen_gid_num)               
                        elif node_panduan[0] not in node_arr_tw:
                            line_arr_tw.append(line)
                            line_gid_mid_tw.append(line[0])
                            if node_panduan[0][0] != famen_gid_num:
                                node_arr_tw.append(node_panduan[0])
                            else:
                                get_result_twice(line_table_name,node_table_name,gid_num,famen_gid_num)
                
            else:
                #line_arr_tw.append(ori_gid_num)
                temp1_tw =(ori_gid_num,get_geom(line_table_name,ori_gid_num)[0][0])
                line_arr_tw.append(temp1_tw)
                node_arr_tw.append(node_panduan[0])
                line_arra = get_inter_line(line_table_name,ori_gid_num)#获取与ori_gid相交的线
                for line in line_arra:                                 #遍历 node与线进行point in line判断
                    if point_in_line(node_panduan[0][-1],line[-1])[0][0] == False:  #当node与相邻的线不相交时，放入line_array_temp
                        line_array_temp.append(line)
        #情景三 当目标线段两端没有端点时
        else:
            line_array_temp = get_inter_line(line_table_name,ori_gid_num)
         ##############由线 去判断 去确定点儿。。。   
        #进行循环获取筛选
        line_array = line_array_temp
        for line in line_array:
            gid_num = line[0]
            if gid_num not in line_gid_mid_tw:
                node_panduan = get_inter_node(line_table_name,node_table_name,gid_num)
                #判断失效阀门点儿是不是在node_panduan里边
                #此时的线上肯定不会又两个阀门儿点儿
                if len(node_panduan)==0:
                    line_arr_tw.append(line)
                    line_gid_mid_tw.append(line[0])
                    get_result_twice(line_table_name,node_table_name,gid_num,famen_gid_num)               
                elif node_panduan[0] not in node_arr_tw:
                    line_arr_tw.append(line)
                    line_gid_mid_tw.append(line[0])
                    if node_panduan[0][0] != famen_gid_num:
                        node_arr_tw.append(node_panduan[0])
                    else:
                        get_result_twice(line_table_name,node_table_name,gid_num,famen_gid_num)
##############################服务类定义##########################################
#纵剖面 
class vertical_profile(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        node1 = self.get_argument('node1')
        node2 = self.get_argument('node2')
        pipe_table = self.get_argument('pipe_table')
        try:
            ree = vertical_profile_fun(node1,node2,pipe_table)
            result = ree.encode('utf-8').decode('unicode_escape')
            self.write({"result":json.loads(result)})
        except:
            self.write({"result":"boy,note the parameter"})
#横剖面
class horizontal_profile(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        linestr = self.get_argument('linestring')
        pipe_table = self.get_argument('pipe_table')
        try:
            ree = horizontal_profile_fun(linestr,pipe_table)
            result = ree.encode('utf-8').decode('unicode_escape')
            self.write({"result":json.loads(result)})
        except:
            self.write({"result":"boy,note the parameter"})

#画多边形选择范围内的数据类型
class polygon_getdata(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        linestring_str = self.get_argument('linestring')
        table_name = self.get_argument('table_name')
        try:
            ree = polygon_inter(linestring_str,table_name)
            self.write({"result":ree})
        except:
            self.write({"result":"boy,note the parameter"})
#线的buffer 范围内的数据
class linebuffer_getdata(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        linestring_str = self.get_argument('linestring')
        table_name = self.get_argument('table_name')
        buffer_dis = self.get_argument('dis')
        try:
            ree = linebuffer_inter(linestring_str,table_name,buffer_dis)
            self.write({"result":ree})
        except:
            self.write({"result":"boy,note the parameter"})
#点的buffer范围内的数据
class pointbuffer_getdata(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        x = self.get_argument('x')
        y = self.get_argument('y')
        table_name = self.get_argument('table_name')
        buffer_dis = self.get_argument('dis')
        try:
            ree = pointbuffer_inter(x,y,table_name,buffer_dis)
            self.write({"result":ree})
        except:
            self.write({"result":"boy,note the parameter"})            
#通过gid获取节点
class linegid_getverticedata(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        pipe_table = self.get_argument('pipe_table')
        vertices_table = self.get_argument('vertice_table')
        gid_num = self.get_argument('gid_num')
        try:
            ree = linegid_getvertice(pipe_table,vertices_table,gid_num)
            self.write({"result":ree})
        except:
            self.write({"result":"boy,note the parameter"})
#连通性分析            
class lt_analysis(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        node1_num = self.get_argument('node1')
        node2_num = self.get_argument('node2')
        table_name = self.get_argument('pipe_table')
        try:
            ree = lt_analysis_fun(node1_num,node2_num,table_name)
            self.write({"result":ree})
        except:
            self.write({"result":"boy,note the parameter"})

#路径规划分析
class path_planning(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        table_name = self.get_argument('pipe_table')
        node1 = self.get_argument('node1')
        node2 = self.get_argument('node2')
        dis_seg = self.get_argument('dis_seg')
        dis_buf = self.get_argument('dis_buf')
        try:
            temp_arr = get_roadLines(table_name,node1,node2)
            lines_arr = line_segmentize(temp_arr,dis_seg)
            buff = line_2_buffer(temp_arr,dis_buf)
            self.write({"result":{"lines":lines_arr,"buffer":buff}})
        except:
            self.write({"result":"boy,note the parameter"}) 

#查找点最近的对应的数据
class get_nearestdata(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        table_name = self.get_argument('table_name')
        x = self.get_argument('x')
        y = self.get_argument('y')
        threshold = self.get_argument('dis')
        try:
            ree = get_nearest(x,y,table_name,threshold)
            self.write({"result":ree})
        except:
            self.write({"result":"boy,note the parameter"})

#根据gid查找数据
class gid_select(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        table_name = self.get_argument('table_name')
        gid_num = self.get_argument('gid')
        try:
            ree = gid_getdata(gid_num,table_name)
            self.write({"result":ree})
        except:
            self.write({"result":"boy,note the parameter"}) 

#爆管分析接口
class bg_analysis(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        #内部函数修改全局变量的方法 哈哈
        global line_arr
        global node_arr
        global line_gid_mid
        line_arr = [] 
        node_arr = [] 
        line_gid_mid = [] 
        water_pipe_table = self.get_argument('pipe_table')
        famen_table = self.get_argument('famen_table')
        pipe_gid = self.get_argument('pipe_gid')
        try:
            get_result(water_pipe_table,famen_table,int(pipe_gid))
            self.write({"pipe_arr":line_arr,"famen_arr":node_arr,"polygon_coor":get_ConvexHull(line_arr)})
        except:
            self.write({"result":"boy,note the parameter"})
#爆管分析接口
class bg_tw_analysis(tornado.web.RequestHandler):
    #设置header 解决跨域问题
    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*") # 这个地方可以写域名
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        
    def get(self):
        #内部函数修改全局变量的方法 哈哈
        global line_arr_tw
        global node_arr_tw
        global line_gid_mid_tw
        line_arr_tw = [] 
        node_arr_tw = [] 
        line_gid_mid_tw = [] 
        water_pipe_table = self.get_argument('pipe_table')
        famen_table = self.get_argument('famen_table')
        pipe_gid = self.get_argument('pipe_gid')
        famen_gid = self.get_argument('famen_gid')
        try:
            get_result_twice(water_pipe_table,famen_table,int(pipe_gid),int(famen_gid))
            self.write({"pipe_arr":list(set(line_arr_tw)),"famen_arr":list(set(node_arr_tw)),"polygon_coor":get_ConvexHull(line_arr_tw)})
        except:
            self.write({"result":"boy,note the parameter"})
############################定义APP########################################
def make_app():
    return tornado.web.Application([
        (r"/vertical_profile", vertical_profile),
        (r"/horizontal_profile", horizontal_profile),
        (r"/polygon_getdata",polygon_getdata),
        (r"/linebuffer_getdata",linebuffer_getdata),
        (r"/pointbuffer_getdata",pointbuffer_getdata),
        (r"/linegid_getverticedata",linegid_getverticedata),
        (r"/lt_analysis",lt_analysis),
        (r"/path_planning",path_planning),
        (r"/get_nearestdata",get_nearestdata),
        (r"/gid_select",gid_select),
        (r"/bg_analysis",bg_analysis),
        (r"/bg_tw_analysis",bg_tw_analysis),
    ],{'debug' : True,})

def lop():
    tornado.ioloop.IOLoop.current().start()


if __name__ == "__main__":
    app = make_app()
    app.listen(5000)
    lop()

















